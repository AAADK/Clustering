/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.apache.hadoop.mapred;

import edu.msu.cme.rdp.hadoop.distance.mapred.keys.DistanceAndComparison;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.util.GenericOptionsParser;
import org.apache.hadoop.io.SequenceFile;
import org.apache.hadoop.io.compress.GzipCodec;

/**
 *
 * @author Jordan Fish <fishjord at msu.edu>
 */
public class SortPartialResults {

    public static void main(String[] args) throws Exception {

        Configuration conf = new Configuration();
        args = new GenericOptionsParser(conf, args).getRemainingArgs();

        if (args.length != 2) {
            System.err.println("USAGE: ReadPartialResultFile <job_dir> <expected_splits>");
            System.exit(1);
        }

        FileSystem fs = FileSystem.getLocal(conf);

        CombinedIntermediateSortedReader reader = CombinedIntermediateSortedReader.fromDirectory(conf, new File(args[0]));
        System.err.println("Created reader");
        DistanceAndComparison dist;
        NullWritable nw = NullWritable.get();
	GzipCodec codec = new GzipCodec();
	codec.setConf(conf);

	SequenceFile.Writer out = SequenceFile.Writer.createWriter(fs, conf, new Path("sorted_distances.seq"), DistanceAndComparison.class, NullWritable.class, SequenceFile.CompressionType.BLOCK, codec);
	long processed = 0;
	long start = System.currentTimeMillis();

	int lastDist = 0;
        while((dist = reader.next()) != null) {
	    out.append(dist, nw);
	    processed++;
	    if(processed % 1000000 == 0) {
		System.err.println("Processed " + processed + " edges (last dist=" + dist.distance + ") in " + (System.currentTimeMillis() - start) / 1000.0f + "s");
	    }
	    if(lastDist > dist.distance) {
		throw new IllegalStateException("last distance: " + lastDist + " thisdist: " + dist.distance);
	    }
        }
	out.close();
    }
}
